using BugsFramework;
using static BugsFramework.BFParser;
using VulnerabilityDescription;

namespace VulnerabilityEditor
{
    public partial class VulnerabilityForm : Form
    {
        readonly IEnumerable<(TreeView treeView, TextBox textBox)> CommentMap;

        public VulnerabilityForm()
        {
            InitializeComponent();
            CommentMap = new[]
            {
                (causes, causeComment),
                (operations, operationComment),
                (consequences, consequenceComment),
                (operationAttributes, operationAttributeComment),
                (operandAttributes, operandAttributeComment),
            };
        }

        private void BFEditor_Load(object sender, EventArgs e)
        {
            UITools.KeepSelectionColor(vulnerability);
            UITools.KeepSelectionColor(classes);
            UITools.KeepSelectionColor(operations);
            UITools.KeepSelectionColor(causes);
            UITools.KeepSelectionColor(consequences);

            Editing = Edited = false;
            NewVulnerabilityNode(BWF.Bug);
        }

        #region Properties

        public Vulnerability? Vulnerability
        {
            get => !VulnerabilityNodes.Any() ? null : new Vulnerability()
            {
                Bug = VulnerabilityNodes.Take(1)?.SingleOrDefault(w => w.TypeBWF == BWF.Bug)?.Weakness ?? throw new Exception("Missing Bug"),
                Weaknesses = VulnerabilityNodes.Where(w => w.TypeBWF == BWF.Weakness).Select(w => w.Weakness).ToArray(),
                Failure = VulnerabilityNodes.TakeLast(1)?.SingleOrDefault(w => w.TypeBWF == BWF.Failure)?.Weakness ?? throw new Exception("Missing Failure"),
            };
            set
            {
                vulnerability.Nodes.Clear();
                if (value != null)
                {
                    vulnerability.Nodes.Add(new TreeNodeWeakness(value.Bug, BWF.Bug));
                    if (value.Weaknesses != null)
                        vulnerability.Nodes.AddRange(value.Weaknesses.Select(w => new TreeNodeWeakness(w, BWF.Weakness)).ToArray());
                    vulnerability.Nodes.Add(new TreeNodeWeakness(value.Failure, BWF.Failure));
                }
                SelectedVulnerabilityNode = VulnerabilityNodes.FirstOrDefault();
            }
        }
        public IEnumerable<TreeNodeWeakness> VulnerabilityNodes => vulnerability.SubNodes<TreeNodeWeakness>();

        public TreeNodeWeakness? SelectedVulnerabilityNode
        {
            get => vulnerability.SelectedNode as TreeNodeWeakness;
            set
            {
                vulnerability.SelectedNode = value;
                if (value is null) vulnerability_AfterSelect(default!, default!);
            }
        }

        public BWF _CurrentType = BWF.Failure;
        public BWF CurrentType
        {
            get => _CurrentType;
            set
            {
                _CurrentType = value;
                bugGroupBox.Text = value.ToString() + ":";

                classes.SetNodes(Parser.GetClasses(value).Select(i =>
                    new TreeNodeX(i.Key.Name, i.Key.Definition, i.Value.Select(j =>
                        new TreeNodeX(j.Name, j.Definition)))));
            }
        }

        public Weakness? CurrentWeakness
        {
            get => classes.SelectedNode is not TreeNodeX classNode ? throw new Exception("Invalid Cause") : new Weakness()
            {
                Type = classNode.Parent.Name,
                Class = classNode.Name,
                Cause = causes.SelectedNode is TreeNodeX causeNode && !causeNode.HasChildren() ?
                    new Cause() { Type = causeNode.Parent.Name, Value = causeNode.Name, Comment = causeNode.Comment }
                    : throw new Exception("Invalid Cause"),
                Operation = operations.SelectedNode is TreeNodeX operationNode && !operationNode.HasChildren() ?
                    new Operation() { Value = operationNode.Name, Comment = operationNode.Comment }
                    : throw new Exception("Invalid Operation"),
                Consequence = consequences.SelectedNode is TreeNodeX consequenceNode && !consequenceNode.HasChildren() ?
                    new Consequence() { Type = consequenceNode.Parent.Name, Value = consequenceNode.Name, Comment = consequenceNode.Comment }
                    : throw new Exception("Invalid Consequence"),
                Attributes = new Attributes
                {
                    OperationAttribute = new OperationAttribute()
                    {
                        Attribute = operationAttributes.SubNodes<TreeNodeX>().SelectMany(t => t.SubNodes.Where(x => x.Checked).Select(x =>
                            new VulnerabilityDescription.Attribute() { Type = t.Name, Value = x.Name, Comment = x.Comment })).ToArray()
                    },
                    OperandAttribute = operandAttributes.SubNodes<TreeNodeX>().Select(t => new OperandAttribute()
                    {
                        Name = t.Name,
                        Attribute = t.SubNodes.SelectMany(a => a.SubNodes.Where(v => v.Checked)
                            .Select(v => new VulnerabilityDescription.Attribute { Type = a.Name, Value = v.Name, Comment = v.Comment })).ToArray()
                    }).Where(x => x.Attribute!.Any()).ToArray()
                }
            };
            set
            {
                if (value is Weakness weakness && classes.SelectByName(weakness.Class))
                {

                    causes.SelectByName(weakness.Cause.Value, weakness.Cause.Comment);
                    operations.SelectByName(weakness.Operation.Value, weakness.Operation.Comment);
                    consequences.SelectByName(weakness.Consequence.Value, weakness.Consequence.Comment);

                    foreach (TreeNodeX t in operationAttributes.Nodes)
                    {
                        t.Checked = false;
                        var tx = weakness.Attributes?.OperationAttribute?.Attribute?.SingleOrDefault(a => a.Type == t.Name);
                        foreach (TreeNodeX v in t.Nodes)
                        {
                            v.Checked = (v.Name == tx?.Value); //xxx in check event uncheck the rest
                            if (v.Checked) v.Comment = tx?.Comment;
                        }
                    }

                    foreach (TreeNodeX t in operandAttributes.Nodes)
                    {
                        t.Checked = false;
                        var tx = weakness.Attributes?.OperandAttribute?.SingleOrDefault(a => a.Name == t.Name);
                        foreach (TreeNodeX n in t.Nodes)
                        {
                            n.Checked = false;
                            var nx = tx?.Attribute?.SingleOrDefault(a => a.Type == n.Name);
                            foreach (TreeNodeX v in n.Nodes)
                            {
                                v.Checked = (v.Name == nx?.Value); //xxx in check event uncheck the rest
                                if (v.Checked) v.Comment = nx?.Comment;
                            }
                        }
                    }
                }
                else classes_AfterSelect(classes, default!);
                Editing = false;
            }
        }

        Cause? PeerCause => (SelectedVulnerabilityNode?.NextNode as TreeNodeWeakness)?.Weakness.Cause;
        Consequence? PeerConsequence => ((SelectedVulnerabilityNode is TreeNodeWeakness current ? current.PrevNode : VulnerabilityNodes.LastOrDefault()) as TreeNodeWeakness)?.Weakness.Consequence;

        #endregion Properties

        #region Properties to control editing

        bool _Editing = false;
        bool Editing {
            get => _Editing;
            set
            {
                _Editing = value;
                buttonCommit.Enabled = value;
                buttonRollback.Enabled = value;
            }
        }

        bool _Edited = false;
        bool Edited
        {
            get => _Edited;
            set
            {
                _Edited = value;
            }
        }

        private void Commit()
        {
            if (!Editing) return;
            if (CurrentWeakness is not Weakness weakness) return;

            if (SelectedVulnerabilityNode is TreeNodeWeakness selection)
                selection.SetWeakness(weakness);
            else 
                vulnerability.Nodes.Add(new TreeNodeWeakness(weakness, CurrentType));

            Editing = false;
            Edited = true;
        }

        private bool TryCommit()
        {
            try
            {
                Commit();
                return true; // !!! CurrentWeakness is not null
            }
            catch(Exception error) 
            {
                Editing = false;
                if (MessageBox.Show($"{error.Message}{Environment.NewLine}Continue anyway?", "Error", MessageBoxButtons.YesNo) == DialogResult.Yes)
                {
                    CurrentWeakness = SelectedVulnerabilityNode?.Weakness; // Rollback!
                    return true;
                }
                else
                {
                    Editing = true;
                    return false;
                }
            } 
        }

        private void NewVulnerabilityNode (BWF typeBWF)
        {
            if (!TryCommit()) return;

            CurrentType = typeBWF;
            SelectedVulnerabilityNode = null;
        }

        #endregion

        #region File New/Open/Save

        private void onFileNew(object sender, EventArgs e)
        {
            if (Editing || Edited)
                if (MessageBox.Show("Changes are not saved. Continue anyway?", "New", MessageBoxButtons.YesNo) != DialogResult.Yes) 
                    return;

            Editing = Edited = false;
            Vulnerability = null;
            NewVulnerabilityNode(BWF.Bug);
        }

        private void onFileOpen(object sender, EventArgs e)
        {
            if ((Editing || Edited) && (MessageBox.Show("Changes are not saved. Continue anyway?", "Open", MessageBoxButtons.YesNo) != DialogResult.Yes)) return;
            if (openFileDialog.ShowDialog() != DialogResult.OK) return;

            if (TryLoadVulnerability(openFileDialog.FileName) is not Vulnerability vulnerability) return;
            Editing = Edited = false;
            Vulnerability = vulnerability;

            static Vulnerability? TryLoadVulnerability(string fileName)
            {
                try { return VulnerabilitySerializer.Load(fileName); }
                catch (Exception error) { MessageBox.Show(error.Message, "Open"); return null; }
            }
        }

        private void onFileSave(object sender, EventArgs e)
        {
            try
            {
                if (Editing) Commit();
                if (Vulnerability is not Vulnerability vulnerability) return;

                if (saveFileDialog.ShowDialog() != DialogResult.OK) return;

                VulnerabilitySerializer.Save(vulnerability, saveFileDialog.FileName);
                Editing = Edited = false;
            }
            catch (Exception error)
            {
                MessageBox.Show(error.Message);
            }
        }

        private void onFileClose(object sender, EventArgs e)
        {
            if (Editing || Edited)
                if (MessageBox.Show("Changes are not saved. Continue anyway?", "Exit", MessageBoxButtons.YesNo) != DialogResult.Yes)
                    return;

            Close();
        }

        #endregion


        private void vulnerability_BeforeSelect(object sender, TreeViewCancelEventArgs e) => e.Cancel = !TryCommit();

        private void vulnerability_AfterSelect(object sender, TreeViewEventArgs e)
        {
            var node = SelectedVulnerabilityNode;
            if (node is not null) CurrentType = node!.TypeBWF;
            CurrentWeakness = node?.Weakness;

            peerConseqeunce.Text = PeerConsequence?.Value;
            peerCause.Text = PeerCause?.Value;

            prevButton.Enabled = CurrentType != BWF.Bug;
            nextButton.Enabled = CurrentType != BWF.Failure;
            endButton.Enabled = vulnerability.Nodes.Count > 0 || Editing;  
        }

        private void classes_AfterSelect(object sender, TreeViewEventArgs e)
        {
            foreach (var (treeView, textBox) in CommentMap)
            {
                treeView.Nodes.Clear();
                textBox.Text = null;
                textBox.Enabled = false;
            }
            if (classes.SelectedNode is not TreeNodeX selectedClass) return; 
            else Editing = true;

            var peerCauseType = PeerCause?.Type;
            var peerConsequenceType = PeerConsequence?.Type;
            var typeBWF = CurrentType;

            causes.SetNodes(Parser.GetCauses(selectedClass.Name).Select(i =>
            {
                var mismatch = (i.Key.BWFType != typeBWF) || (peerConsequenceType?.Equals(i.Key.Name) == false);
                return new TreeNodeX(i.Key.Name, i.Key.Definition, disable: mismatch, children: i.Value.Select(j =>
                    new TreeNodeX(j, Parser.GetDefinition(j), mismatch))) ;
            }));
            if (PeerConsequence?.Value is string name) causes.SelectByName(name);

            consequences.SetNodes(Parser.GetConsequences(selectedClass.Name).Select(i =>
            {
                var mismatch = peerCauseType?.Equals(i.Key.Name) == false;
                return new TreeNodeX(i.Key.Name, i.Key.Definition, disable: mismatch, children: i.Value.Select(j =>
                    new TreeNodeX(j, Parser.GetDefinition(j), mismatch)));
            }));

            operations.SetNodes(Parser.GetOperations(selectedClass.Name).Select(i =>
                new TreeNodeX(i, Parser.GetDefinition(i))));
            operationAttributes.SetNodes(Parser.GetOperationAttributes(selectedClass.Name).Select(i =>
                new TreeNodeX(i.Key.Name, i.Key.Definition, i.Value.Select(k =>
                    new TreeNodeX(k, Parser.GetDefinition(k))))));
            operandAttributes.SetNodes(Parser.GetOperandAttributes(selectedClass.Name).Select(i =>
                new TreeNodeX(i.Key, null, i.Value.Select(j =>
                    new TreeNodeX(j.Key.Name, j.Key.Definition, j.Value.Select(k =>
                        new TreeNodeX(k, Parser.GetDefinition(k))))))));
        }

        private void any_beforeSelect(object sender, TreeViewCancelEventArgs e)
            => e.Cancel = e.Node.HasChildren() || (e.Node is TreeNodeX node && node.Disabled);

        private void any_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (sender is not TreeView treeView
                || treeView.SelectedNode is not TreeNodeX node
                || CommentMap.FirstOrDefault(m => m.treeView == treeView) is not (_, TextBox commentTextBox)) return;
            commentTextBox.Text = node.Comment;
            commentTextBox.Enabled = true;
            if ((treeView != operationAttributes) && (treeView != operandAttributes)) Editing = true;
        }

        private void comment_TextChanged(object sender, EventArgs e) => Editing = true;

        private void comment_Validating(object sender, System.ComponentModel.CancelEventArgs e)
        {
            if (sender is not TextBox textBox
                || CommentMap.FirstOrDefault(m => m.textBox == textBox) is not (TreeView treeView, _)
                || treeView.SelectedNode is not TreeNodeX node) return;
            node.Comment = textBox.Text;
        }

        private void attributes_BeforeCheck(object sender, TreeViewCancelEventArgs e)
        {
            if (e.Action == TreeViewAction.Unknown) return; // not user activity
            if (e.Node is not TreeNode node || node.Checked) return; // uncheck is always fine

            if (node.FirstNode != null) e.Cancel = true; // do not check non-leaf nodes
            else foreach (TreeNode peer in Peers(node)) peer.Checked = false; // uncheck peers

            static IEnumerable<TreeNode> Peers (TreeNode node)
            {
                for (TreeNode peer = node; (peer = peer.PrevNode) != null;) yield return peer;
                for (TreeNode peer = node; (peer = peer.NextNode) != null;) yield return peer;
            }
        }
        private void attributes_AfterCheck(object sender, TreeViewEventArgs e) => Editing = true;


        private void buttonRollback_Click(object sender, EventArgs e) => CurrentWeakness = SelectedVulnerabilityNode?.Weakness;

        private void buttonCommit_Click(object sender, EventArgs e)
        {
            try
            {
                Commit();
            }
            catch (Exception error)
            {
                MessageBox.Show(error.Message);
            }
        }

        private void prevButton_Click(object sender, EventArgs e)
        {
            if (!TryCommit()) return;
            vulnerability.SelectedNode = SelectedVulnerabilityNode is TreeNode node ? node.PrevNode : VulnerabilityNodes.LastOrDefault();
        }

        private void nextButton_Click(object sender, EventArgs e)
        {
            if (!TryCommit()) return;

            if (SelectedVulnerabilityNode?.NextNode is TreeNode nextNode)
                vulnerability.SelectedNode = nextNode;
            else 
                NewVulnerabilityNode(VulnerabilityNodes.Any() ? BWF.Weakness : BWF.Bug);
        }

        private void endButton_Click(object sender, EventArgs e)
        {
            if (!TryCommit() || (vulnerability.Nodes.Count == 0)) return;

            if (VulnerabilityNodes.LastOrDefault() is TreeNodeWeakness node && node.TypeBWF == BWF.Failure)
                vulnerability.SelectedNode = node;
            else
                NewVulnerabilityNode(BWF.Failure);
        }
    }
}
